# 04-27 — 04-29

### 1. 代码性能指标

- 健壮性：代码抗击风险的能力

  - 目的
    - 避免和程序无关的因素，导致代码报错
    - 快速给出问题反馈
    - 不至于因为非必要BUG，而导致程序执行中断

  - 做法
    - 参数做好默认值，做好检测
    - 程序做好意外情况处理

- 可读性：代码阅读起来很清楚

  - 目的
    - 代码结构清晰
    - 他人能够看懂你的意思
  - 做法
    - 优化丑陋的结构
    
      ```js
      // 典型的丑陋结构
      
      // 1.if-else 分支过长
      if (status === 1) {
        console.log(1);
      } else if (status === 2) {
        console.log(2);
      } else if (status === 3) {
        console.log(3);
      }
      
      // 2.分支套分支
      // 修改前
      if (a === 1) {
        if (b === 2) {
          if (c === 3) {
            console.log("success");
          }
        }
      }
      // 修改后
      if (a === 1 && b === 2 && c === 3) {
        console.log("success");
      }
      
      // 3.Promise 回调地狱 => 可使用 async await 解决
      $.ajax({
        url: "/login",
        success: function () {
          $.ajax({
            url: "/user",
            success: function () {
              $.ajax({
                url: "/menu",
                success: function () {
                  console.log("menu success");
                },
              });
            },
          });
        },
      });
      ```
    
    - 遵循命名规范
      - 常量全大写
      - 类目首字母大写，普通变量首字母小写
      - 局部变量下划线开头
      - 遵循语义化
      
    - 注释

- 可复用性：代码就像积木一样，能够很方便的哪里需要去哪里

  - 目的
    - 重复的操作不用写第二遍
    - 减少代码体积

  - 做法
    - 桥接模式
    - 享元模式
    - 函数式编程
    - 低耦合，高内聚

- 可扩展性：应对以后的变更，可以不用大规模的改动

  - 目的
    - 增加新需求，不用变动现有结构
    - 增加新功能，最好只需要写新功能就好

  - 做法
    - 留出扩展接口
    - 模块低耦合，高内聚
    - 良好的模块组织
    - 良好的扩展方案



# 04-30

### 2. 如何做好函数式编程

- 函数式编程的函数要求

  - 保证纯函数：一个函数的返回结果之依赖于它的参数，同样的输入必定有同样的输出

    ```js
    let a = 10;
    // 非纯函数
    function aPlus1(num) {
      return a + num;
    }
    aPlus1(2);
    
    // 纯函数
    function aPlus2(a, num) {
      return a + num;
    }
    aPlus2(a, 2);
    ```

  - 减少函数副作用：函数副作用就是函数会影响外部的数据，例如 全局变量

    ```js
    // 副作用
    let b = 100;
    function bPlus1() {
      b += 1;
      return b;
    }
    console.log(bPlus1()); // 101
    console.log(b); // 101
    
    // 减少副作用
    // 非引用类型 => 当参数传入
    b = 100;
    function bPlus2(b) {
      b += 1;
      return b;
    }
    console.log(bPlus2(b)); // 101
    console.log(b); // 100
    // 引用类型
    // Object => 拷贝一份新的，如: Object.create()、JSON.parse(JSON.stringify())
    let obj = { b: 1000 };
    function objPlus(obj) {
      let _obj = Object.create(obj);
      // let _obj = JSON.parse(JSON.stringify(obj))
      _obj.b += 1;
      return _obj;
    }
    console.log(objPlus(obj)); // { b: 1001 }
    console.log(obj); // { b: 1000 }
    // Array => 展开运算符(...)、for in
    let arr = [1, 2, 3];
    function arrPlus(arr) {
      let _arr = [...arr];
      _arr[0] += 10;
      return _arr;
    }
    console.log(arrPlus(arr)); // [11, 2, 3]
    console.log(arr); // [1, 2, 3]
    ```

- 工程化下的函数式编程

  - 模块化 类

    ```js
    // ES6
    function class1() {}
    
    export default class1;
    import class1 from "./mode1.js";
    
    // common js
    function class1() {}
    
    module.exports = class1;
    const class1 = require("./mode1.js");
    ```

  - 函数式

    ```js
    // ES6
    export function f1() {}
    export function f2() {}
    
    import { f1 } from "./model1.js";
    import * as all from "./model1.js";
    
    // common js
    export function f1() {}
    export function f2() {}
    exports.f1 = f1;
    exports.f2 = f2;
    
    const f1 = require("./model1.js").f1();
    const all = require("./model1.js");
    ```

### 3. Compose 和 Pipe 函数

- 目的

  - 函数式编程后执行的一些问题

    - 值的传递写起来不方便：如果要连续执行一系列函数，并且传递计算某个值，会写起来很难受
    - 连续调用一系列函数，写起来会很麻烦

    ```js
    function addTwo(num) {
      return num + 2;
    }
    function minusTwo(num) {
      return num - 2;
    }
    function multiplyTwo(num) {
      return num * 2;
    }
    
    // +2 => *2 => -2
    let result = addTwo(10);
    result = multiplyTwo(result);
    result = minusTwo(result);
    console.log(result);
    ```

- Compose

  1. 为了方便我们连续执行方法，把自己调用传值的过程封装起来
  2. 我们只需要告诉 compose 函数要执行哪些方法，它就会自动执行
  3. 执行顺序: 自右至左

  ```js
  function compose() {
    const args = [].slice.apply(arguments);
    return function (num) {
      // 实现逻辑
      /* var _result = num;
      for (var i = args.length - 1; i >= 0; i--) {
        _result = args[i](_result);
      }
      return _result; */
  
      // 简化版 reduceRight()
      return args.reduceRight((res, cb) => cb(res), num);
    };
  }
  compose(minusTwo, multiplyTwo, addTwo)(10)
  ```

- Pipe：功能同上，只是执行顺序不同，为 自左至右

- 链式调用：Promise，和面向对象的链式调用有区别

  ```js
  Promise.resolve(10)
    .then(addTwo)
    .then(multiplyTwo)
    .then(minusTwo)
    .then((res) => console.log(res));
  ```