[TOC]

# 06-01

### 1. Vue 优化方式 

- `v-if` 和 `v-show`
- 使用 `Object.freeze()` 方式冻结 `data` 中的属性，从而阻止数据劫持
- 组件销毁的时候会断开所有与实例联系，但是除了 `addEventListener`，所以当一个组件销毁的时候需要手动去 `removeEventListener`
- 图片懒加载
- 路由懒加载
- 为减少重新渲染和创建 DOM 节点的时间，采用虚拟 DOM

### 2. vue-router 的模式 

1. hash 模式

   监听 `hashchange` 事件实现前端路由，利用 URL 中的 hash 来模拟一个 hash，以保证 url 改变时，页面不会重新加载。

2. history 模式

   利用 `pushstate` 和 `replacestate` 来将 URL 替换但不刷新，但是有一个致命点就是，一 旦刷新的话，就会可能 404，因为没有当前的真正路径，要想解决这一问题需要后端配合，将不存在的路径重定向到入口文件。



# 06-07

### 3. diff 算法

​		diff 算法是指对新旧虚拟节点进行对比，并返回一个 `patch` 对象，用来存储两个节点不同的地方，最后利用 `patch` 记录的消息局部更新 DOM



# 06-08

### 4. 虚拟 DOM 的优缺点

- 缺点

  首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 `innerHTML` 插入慢 

- 优点

  1. 减少了 DOM 操作，减少了回流与重绘

  2. 保证性能的下限，虽说性能不是最佳，但是它具备局部更新的能力，所以大部分时候还是比正常的 DOM 性能高很多



# 06-09

### 5. 什么是虚拟 DOM

* 虚拟 DOM 是相对于浏览器所渲染出来的真实 DOM 的，在 react，vue 等技术出现之前， 我们要改变页面展示的内容只能通过遍历查询 DOM 树的方式找到需要修改的 DOM，然后修改样式行为或者结构，来达到更新 UI 的目的。 
* 这种方式相当消耗计算资源，因为每次查询 DOM 几乎都需要遍历整棵 DOM 树，如果建立一个与 DOM 树对应的虚拟 DOM 对象（ JS 对象），以对象嵌套的方式来表示 DOM 树，那么每次 DOM 的更改就变成了 JS 对象的属性的更改，这样一来就能查找 JS 对象的属性变化要比查询 DOM 树的性能开销小



# 06-10

### 6. Vue 双向绑定原理

* Vue 数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的
* 利用了 `Object.defineProperty()` 这个方法重新定义了对象获取属性值（get）和设置属性值（set）



# 06-11

### 7. `vue-router` 中可选参数

* /router/index.js

  `?` 表示可选，放在参数之后

  以下代码，`id` 为必传；`type` 为可选参数，可传可不传

  ```
  const routes = [
    {
      path: "/task-detail/:id/:type?",
      name: "TaskDetail",
      component: () => import("../views/home/TaskDetail.vue"),
    },
  ]
  ```



# 06-12

### 8. `@click` 和 `@click()` 打印信息的区别

```vue
<template>
  <div>
    <el-button @click="handleClick1"></el-button>
		<el-button @click="handleClick2()"></el-button>
  </div>
</template>

<script>
export default {
  methods: {
    handleClick1(e) {
      console.log(e); // PointerEvent
    },
    handleClick2(e) {
      console.log(e); // undefined
    },
 	}
}
</script>

```