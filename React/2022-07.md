[TOC]

# 07-02

### 1. 调用 `super(props)` 的目的

`Super()` 调用父类的构造方法，有 `super`，组件才有自己的 `this`，在组件全局中都可以使用 `this`，如果只是 `constructor` 而不执行 `super`，之后的 `this` 都是错的，`super` 继承父组件的 `this`



# 07-03

### 2. React 中构建组件的方式

* 自定义组件：函数组件或者无状态组件。组件首字母大写
* 类组件：一个类组件必须实现一个 `render` 方法，这个方法必须返回一个 jsx 元素，要用一个外层的元素把所有内容包裹起来



# 07-04

### 3. React 事件处理 —— 修改 `this` 指向

1. 通过 `bind` 方法进行原地绑定，从而改变 `this` 指向 
2. 通过创建箭头函数
3. 在 `constructor` 中提前对事件进行绑定
4. 将事件调用的写法改为箭头函数的形式



# 07-05

### 4. 调用 `setState` 之后发生了什么

1. React 在调用 `setstate` 后，会将传入的参数对象和组件当前的状态合并，触发调和过程

2. 在调和过程中，React 会根据新的状态构建 React 元素树，重新渲染整个 UI 界面，在得到元素树之后，会自动计算新老节点的差异，根据差异对界面进行最小化重新渲染



# 07-06

### 5. React 性能优化方案

1. 重写 `shouldComponentUpdate` 来避免不必要的 dom 操作
2. 使用 `production` 版本的 React.js
3. 使用 `key` 来帮助 React 识别列表中所有子组件的最小变化



# 07-09

### 6. 怎么阻止组件的渲染

在组件的 `render` 方法中返回 `null`，并不会影响触发组件的生命周期方法



# 07-15

### 7. 理解 JSX

* JSX 是 JavaScript 语法的一种语法扩展，并拥有 JavaScript 的全部功能
* JSX 生产 React ”元素“，你可以将任何的 JavaScript 表达式封装在花括号里，然后将其嵌入到 JSX 中
* 在编译完成之后，JSX 表达式就变成了常规的 JavaScript 对象，这意味着你可以在 `if` 语句和 `for` 循环内部使用 JSX，将它赋值给变量，接受它作为参数，并从函 数中返回它



# 07-17

### 8. 在 React 中，refs 的作用

* `refs` 可以用于获取一个 DOM 节点或者 React 组件的引用
* 何时使用：管理焦点 / 文本选择，触发命令动画，或者和第三方 DOM 库集成
* 你应该避免使用 `String` 类型的 `refs` 和内联的 `ref` 回调，`refs` 回调是 React 所推荐的



# 07-18

### 9. 何为高阶组件（higher order component）

* 高阶组件是一个以组件为参数并返回一个新组件的函数。
* `HOC` 允许你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 `connect` 函数。
* 除了简单分享工具库和简单的组合，HOC 最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 `HOC`。



# 07-22

### 10. 为什么建议传递给 `setState` 的参数是一个 `callback` 而不是一个对象

因为 `this.props` 和 `this.state` 的更新可能是异步的，不能依赖它们的值去计算下一个 `state`。



# 07-23

### 11. 除了在构造函数中绑定 `this`，还有其它方式吗

可以使用属性初始值设定项（property initializers）来正确绑定回调，`create-react-app` 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。



# 07-24

### 12. 怎么阻止组件的渲染

在组件的 `render` 方法中返回 `null` 并不会影响触发组件的生命周期方法。



# 07-25

### 13.（在构造函数中）调用 `super(props)` 的目的是什么 

在 `super()` 被调用之前，子类是不能使用 `this` 的，在 ES2015 中，子类必须在 `constructor` 中调用 `super()`。传递 `props` 给 `super()` 的原因则是便于（在子类中）能在 `constructor` 访问 `this.props`。